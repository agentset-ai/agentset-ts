/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/namespace": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of namespaces
         * @description Retrieve a list of namespaces for the authenticated organization.
         */
        get: operations["listNamespaces"];
        put?: never;
        /**
         * Create a namespace.
         * @description Create a namespace for the authenticated organization.
         */
        post: operations["createNamespace"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a namespace
         * @description Retrieve the info for a namespace.
         */
        get: operations["getNamespace"];
        put?: never;
        post?: never;
        /**
         * Delete a namespace.
         * @description Delete a namespace for the authenticated organization. This will delete all the data associated with the namespace.
         */
        delete: operations["deleteNamespace"];
        options?: never;
        head?: never;
        /**
         * Update a namespace.
         * @description Update a namespace for the authenticated organization. If there is no change, return it as it is.
         */
        patch: operations["updateNamespace"];
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/ingest-jobs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of ingest jobs
         * @description Retrieve a paginated list of ingest jobs for the authenticated organization.
         */
        get: operations["listIngestJobs"];
        put?: never;
        /**
         * Create an ingest job
         * @description Create an ingest job for the authenticated organization.
         */
        post: operations["createIngestJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/ingest-jobs/{jobId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve an ingest job
         * @description Retrieve the info for an ingest job.
         */
        get: operations["getIngestJobInfo"];
        put?: never;
        post?: never;
        /**
         * Delete an ingest job
         * @description Delete an ingest job for the authenticated organization.
         */
        delete: operations["deleteIngestJob"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/ingest-jobs/{jobId}/re-ingest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Re-ingest a job
         * @description Re-ingest a job for the authenticated organization.
         */
        post: operations["reIngestJob"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/documents": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a list of documents
         * @description Retrieve a paginated list of documents for the authenticated organization.
         */
        get: operations["listDocuments"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/documents/{documentId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve a document
         * @description Retrieve the info for a document.
         */
        get: operations["getDocument"];
        put?: never;
        post?: never;
        /**
         * Delete a document
         * @description Delete a document for the authenticated organization.
         */
        delete: operations["deleteDocument"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search a namespace
         * @description Search a namespace for a query.
         */
        post: operations["search"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/uploads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create presigned URL for file upload
         * @description Generate a presigned URL for uploading a single file to the specified namespace.
         */
        post: operations["createUpload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/namespace/{namespaceId}/uploads/batch": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create presigned URLs for batch file upload
         * @description Generate presigned URLs for uploading multiple files to the specified namespace.
         */
        post: operations["createBatchUpload"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description The embedding model config. If not provided, our managed embedding model will be used. Note: You can't change the embedding model config after the namespace is created. */
        "embedding-model-config": components["schemas"]["openai-embedding-config"] | components["schemas"]["azure-embedding-config"] | components["schemas"]["voyage-embedding-config"] | components["schemas"]["google-embedding-config"] | {
            /** @constant */
            provider: "MANAGED_OPENAI";
            /** @enum {string} */
            model: "text-embedding-3-large";
        };
        /** OpenAI Embedding Config */
        "openai-embedding-config": {
            /** @constant */
            provider: "OPENAI";
            model: components["schemas"]["openai-embedding-model-enum"];
            apiKey: string;
        };
        /**
         * @description The OpenAI embedding model enum.
         * @enum {string}
         */
        "openai-embedding-model-enum": "text-embedding-3-small" | "text-embedding-3-large";
        /** Azure Embedding Config */
        "azure-embedding-config": {
            /** @constant */
            provider: "AZURE_OPENAI";
            model: components["schemas"]["openai-embedding-model-enum"];
            /**
             * Format: uri
             * @description The resource name of the Azure OpenAI API. https://{resourceName}.openai.azure.com/v1
             * @example my-resource-name
             */
            resourceName: string;
            /** @description The deployment name of the Azure OpenAI API. */
            deployment: string;
            /** @description The API key for the Azure OpenAI API. */
            apiKey: string;
            /**
             * @description The API version for the Azure OpenAI API. Defaults to `preview`.
             * @default preview
             */
            apiVersion: string;
        };
        /** Voyage Embedding Config */
        "voyage-embedding-config": {
            /** @constant */
            provider: "VOYAGE";
            model: components["schemas"]["voyage-embedding-model-enum"];
            apiKey: string;
        };
        /**
         * @description The Voyage embedding model enum.
         * @enum {string}
         */
        "voyage-embedding-model-enum": "voyage-3-large" | "voyage-3" | "voyage-3-lite" | "voyage-code-3" | "voyage-finance-2" | "voyage-law-2";
        /** Google Embedding Config */
        "google-embedding-config": {
            /** @constant */
            provider: "GOOGLE";
            model: components["schemas"]["google-embedding-model-enum"];
            apiKey: string;
        };
        /** @enum {string} */
        "google-embedding-model-enum": "text-embedding-004";
        /** @description The vector store config. If not provided, our MANAGED_PINECONE vector store will be used. Note: You can't change the vector store config after the namespace is created. */
        "create-vector-store-config": {
            /** @constant */
            provider: "MANAGED_PINECONE";
        } | {
            /** @constant */
            provider: "MANAGED_TURBOPUFFER";
        } | components["schemas"]["pinecone-config"] | components["schemas"]["turbopuffer-config"];
        /** Pinecone Config */
        "pinecone-config": {
            /** @constant */
            provider: "PINECONE";
            /** @description The API key for the Pinecone index. */
            apiKey: string;
            /**
             * Format: uri
             * @description The host of the Pinecone index.
             * @example https://example.svc.aped-1234-a56b.pinecone.io
             */
            indexHost: string;
        };
        /** Turbopuffer Config */
        "turbopuffer-config": {
            /** @constant */
            provider: "TURBOPUFFER";
            /** @description The API key for the Turbopuffer index. */
            apiKey: string;
            region: components["schemas"]["turbopuffer-region-enum"];
        };
        /**
         * @description The region for the Turbopuffer index. Check https://turbopuffer.com/docs/regions
         * @enum {string}
         */
        "turbopuffer-region-enum": "gcp-us-central1" | "gcp-us-west1" | "gcp-us-east4" | "gcp-northamerica-northeast2" | "gcp-europe-west3" | "gcp-asia-southeast1" | "gcp-gcp-asia-northeast3" | "aws-eu-central-1" | "aws-eu-west-1" | "aws-us-east-1" | "aws-us-west-2" | "aws-ap-southeast-2" | "aws-us-east-2" | "aws-ap-south-1";
        /**
         * @description The status of the ingest job.
         * @enum {string}
         */
        "ingest-job-status": "BACKLOG" | "QUEUED" | "QUEUED_FOR_RESYNC" | "QUEUED_FOR_DELETE" | "PRE_PROCESSING" | "PROCESSING" | "DELETING" | "CANCELLING" | "COMPLETED" | "FAILED" | "CANCELLED";
        /** @description The cursor to paginate by. */
        "pagination-cursor": string;
        /**
         * @description The direction to paginate by.
         * @enum {string}
         */
        "pagination-cursor-direction": "forward" | "backward";
        /** @description The ingest job payload. */
        "ingest-job-payload": components["schemas"]["text-payload"] | components["schemas"]["file-payload"] | components["schemas"]["managed-file-payload"] | components["schemas"]["batch-payload"];
        /** Text Payload */
        "text-payload": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "TEXT";
            /** @description The text to ingest. */
            text: string;
            fileName?: string | null;
        };
        /** URL Payload */
        "file-payload": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "FILE";
            /** @description The URL of the file to ingest. */
            fileUrl: string;
            fileName?: string | null;
        };
        /** Managed File Payload */
        "managed-file-payload": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MANAGED_FILE";
            /** @description The key of the managed file to ingest. */
            key: string;
            fileName?: string | null;
        };
        /** Batch Payload */
        "batch-payload": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "BATCH";
            items: ({
                /** @constant */
                type: "TEXT";
                /** @description The text to ingest. */
                text: string;
                fileName?: string | null;
                config?: components["schemas"]["ingest-job-config"];
            } | {
                /** @constant */
                type: "FILE";
                /** @description The URL of the file to ingest. */
                fileUrl: string;
                fileName?: string | null;
                config?: components["schemas"]["ingest-job-config"];
            } | {
                /** @constant */
                type: "MANAGED_FILE";
                /** @description The key of the managed file to ingest. */
                key: string;
                fileName?: string | null;
                config?: components["schemas"]["ingest-job-config"];
            })[];
        };
        /** @description The ingest job config. */
        "ingest-job-config": {
            /** @description Soft chunk size. */
            chunkSize?: number;
            /** @description Hard chunk size. */
            maxChunkSize?: number;
            /** @description Custom chunk overlap. */
            chunkOverlap?: number;
            /** @description Custom metadata to be added to the ingested documents. It cannot contain nested objects; only primitive types (string, number, boolean) are allowed. */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            chunkingStrategy?: components["schemas"]["chunking-strategy"];
            strategy?: components["schemas"]["strategy"];
        };
        /**
         * @description The chunking strategy to use. Defaults to `basic`.
         * @enum {string}
         */
        "chunking-strategy": "basic" | "by_title";
        /**
         * @description The strategy to use. Defaults to `auto`.
         * @enum {string}
         */
        strategy: "auto" | "fast" | "hi_res" | "ocr_only";
        /**
         * @description The status of the document.
         * @enum {string}
         */
        "document-status": "BACKLOG" | "QUEUED" | "QUEUED_FOR_RESYNC" | "QUEUED_FOR_DELETE" | "PRE_PROCESSING" | "PROCESSING" | "DELETING" | "CANCELLING" | "COMPLETED" | "FAILED" | "CANCELLED";
        "upload-file-schema": {
            fileName: string;
            contentType: string;
            fileSize: number;
        };
        /** Namespace */
        namespace: {
            /** @description The unique ID of the namespace. */
            id: string;
            /** @description The name of the namespace. */
            name: string;
            /** @description The slug of the namespace. */
            slug: string;
            /** @description The ID of the organization that owns the namespace. */
            organizationId: string;
            /** @description The date and time the namespace was created. */
            createdAt: string;
            /** @default null */
            embeddingConfig: components["schemas"]["embedding-model-configOutput"] | null;
            /** @default null */
            vectorStoreConfig: components["schemas"]["vector-store-config"] | null;
        };
        /** @description The vector store config. */
        "vector-store-config": {
            /** @constant */
            provider: "MANAGED_PINECONE_OLD";
        } | {
            /** @constant */
            provider: "MANAGED_PINECONE";
        } | {
            /** @constant */
            provider: "MANAGED_TURBOPUFFER";
        } | components["schemas"]["pinecone-configOutput"] | components["schemas"]["turbopuffer-configOutput"];
        /** Ingest Job */
        "ingest-job": {
            /** @description The unique ID of the ingest job. */
            id: string;
            /** @description The name of the ingest job. */
            name?: string | null;
            /** @description The namespace ID of the ingest job. */
            namespaceId: string;
            /**
             * @description The tenant ID of the ingest job.
             * @default null
             */
            tenantId: string | null;
            status: components["schemas"]["ingest-job-status"];
            /**
             * @description The error message of the ingest job. Only exists when the status is failed.
             * @default null
             */
            error: string | null;
            payload: components["schemas"]["ingest-job-payloadOutput"];
            /** @default null */
            config: components["schemas"]["ingest-job-configOutput"] | null;
            /** @description The date and time the namespace was created. */
            createdAt: string;
            /**
             * @description The date and time the ingest job was queued.
             * @default null
             */
            queuedAt: string | null;
            /**
             * @description The date and time the ingest job was pre-processed.
             * @default null
             */
            preProcessingAt: string | null;
            /**
             * @description The date and time the ingest job was processed.
             * @default null
             */
            processingAt: string | null;
            /**
             * @description The date and time the ingest job was completed.
             * @default null
             */
            completedAt: string | null;
            /**
             * @description The date and time the ingest job failed.
             * @default null
             */
            failedAt: string | null;
        };
        /** Document */
        document: {
            /** @description The unique ID of the document. */
            id: string;
            /** @description The ingest job ID of the document. */
            ingestJobId: string;
            /**
             * @description A unique external ID.
             * @default null
             */
            externalId: string | null;
            /**
             * @description The name of the document.
             * @default null
             */
            name: string | null;
            /**
             * @description The tenant ID of the ingest job.
             * @default null
             */
            tenantId: string | null;
            status: components["schemas"]["document-status"];
            /**
             * @description The error message of the document. Only exists when the status is failed.
             * @default null
             */
            error: string | null;
            /** @description The source of the document. */
            source: {
                /** @constant */
                type: "TEXT";
                /** @description The text to ingest. */
                text: string;
            } | {
                /** @constant */
                type: "FILE";
                /** @description The URL of the file to ingest. */
                fileUrl: string;
            } | {
                /** @constant */
                type: "MANAGED_FILE";
                /** @description The key of the managed file to ingest. */
                key: string;
            };
            /** @default null */
            properties: {
                /** @description The size of the file in bytes. */
                fileSize: number;
                /** @default null */
                mimeType: string | null;
            } | null;
            /** @description The total number of chunks. */
            totalChunks: number;
            /** @description The total number of tokens. */
            totalTokens: number;
            /** @description The total number of characters. */
            totalCharacters: number;
            /** @description The total number of pages. Will be 0 if the document is not paged (e.g. PDF). */
            totalPages: number;
            /** @description The date and time the document was created. */
            createdAt: string;
            /**
             * @description The date and time the document was queued.
             * @default null
             */
            queuedAt: string | null;
            /**
             * @description The date and time the document was pre-processed.
             * @default null
             */
            preProcessingAt: string | null;
            /**
             * @description The date and time the document was processed.
             * @default null
             */
            processingAt: string | null;
            /**
             * @description The date and time the document was completed.
             * @default null
             */
            completedAt: string | null;
            /**
             * @description The date and time the document failed.
             * @default null
             */
            failedAt: string | null;
        };
        /** Upload Result */
        "upload-result-schema": {
            /**
             * Format: uri
             * @description Presigned URL for file upload. Make a `PUT` request to this URL with the file content and the `Content-Type` header.
             */
            url: string;
            /** @description Key of the file in the storage. You'll send this in the `MANAGED_FILE` payload when creating an ingest job. */
            key: string;
        };
        /** @description The embedding model config. If not provided, our managed embedding model will be used. Note: You can't change the embedding model config after the namespace is created. */
        "embedding-model-configOutput": components["schemas"]["openai-embedding-configOutput"] | components["schemas"]["azure-embedding-configOutput"] | components["schemas"]["voyage-embedding-configOutput"] | components["schemas"]["google-embedding-configOutput"] | {
            /** @constant */
            provider: "MANAGED_OPENAI";
            /** @enum {string} */
            model: "text-embedding-3-large";
        };
        /** OpenAI Embedding Config */
        "openai-embedding-configOutput": {
            /** @constant */
            provider: "OPENAI";
            model: components["schemas"]["openai-embedding-model-enum"];
            apiKey: string;
        };
        /** Azure Embedding Config */
        "azure-embedding-configOutput": {
            /** @constant */
            provider: "AZURE_OPENAI";
            model: components["schemas"]["openai-embedding-model-enum"];
            /**
             * Format: uri
             * @description The resource name of the Azure OpenAI API. https://{resourceName}.openai.azure.com/v1
             * @example my-resource-name
             */
            resourceName: string;
            /** @description The deployment name of the Azure OpenAI API. */
            deployment: string;
            /** @description The API key for the Azure OpenAI API. */
            apiKey: string;
            /**
             * @description The API version for the Azure OpenAI API. Defaults to `preview`.
             * @default preview
             */
            apiVersion: string;
        };
        /** Voyage Embedding Config */
        "voyage-embedding-configOutput": {
            /** @constant */
            provider: "VOYAGE";
            model: components["schemas"]["voyage-embedding-model-enum"];
            apiKey: string;
        };
        /** Google Embedding Config */
        "google-embedding-configOutput": {
            /** @constant */
            provider: "GOOGLE";
            model: components["schemas"]["google-embedding-model-enum"];
            apiKey: string;
        };
        /** Pinecone Config */
        "pinecone-configOutput": {
            /** @constant */
            provider: "PINECONE";
            /** @description The API key for the Pinecone index. */
            apiKey: string;
            /**
             * Format: uri
             * @description The host of the Pinecone index.
             * @example https://example.svc.aped-1234-a56b.pinecone.io
             */
            indexHost: string;
        };
        /** Turbopuffer Config */
        "turbopuffer-configOutput": {
            /** @constant */
            provider: "TURBOPUFFER";
            /** @description The API key for the Turbopuffer index. */
            apiKey: string;
            region: components["schemas"]["turbopuffer-region-enum"];
        };
        /** @description The ingest job payload. */
        "ingest-job-payloadOutput": components["schemas"]["text-payloadOutput"] | components["schemas"]["file-payloadOutput"] | components["schemas"]["managed-file-payloadOutput"] | components["schemas"]["batch-payloadOutput"];
        /** Text Payload */
        "text-payloadOutput": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "TEXT";
            /** @description The text to ingest. */
            text: string;
            fileName?: string | null;
        };
        /** URL Payload */
        "file-payloadOutput": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "FILE";
            /** @description The URL of the file to ingest. */
            fileUrl: string;
            fileName?: string | null;
        };
        /** Managed File Payload */
        "managed-file-payloadOutput": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "MANAGED_FILE";
            /** @description The key of the managed file to ingest. */
            key: string;
            fileName?: string | null;
        };
        /** Batch Payload */
        "batch-payloadOutput": {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "BATCH";
            items: ({
                /** @constant */
                type: "TEXT";
                /** @description The text to ingest. */
                text: string;
                fileName?: string | null;
                config?: components["schemas"]["ingest-job-configOutput"];
            } | {
                /** @constant */
                type: "FILE";
                /** @description The URL of the file to ingest. */
                fileUrl: string;
                fileName?: string | null;
                config?: components["schemas"]["ingest-job-configOutput"];
            } | {
                /** @constant */
                type: "MANAGED_FILE";
                /** @description The key of the managed file to ingest. */
                key: string;
                fileName?: string | null;
                config?: components["schemas"]["ingest-job-configOutput"];
            })[];
        };
        /** @description The ingest job config. */
        "ingest-job-configOutput": {
            /** @description Soft chunk size. */
            chunkSize?: number;
            /** @description Hard chunk size. */
            maxChunkSize?: number;
            /** @description Custom chunk overlap. */
            chunkOverlap?: number;
            /** @description Custom metadata to be added to the ingested documents. It cannot contain nested objects; only primitive types (string, number, boolean) are allowed. */
            metadata?: {
                [key: string]: string | number | boolean;
            };
            chunkingStrategy?: components["schemas"]["chunking-strategy"];
            strategy?: components["schemas"]["strategy"];
        };
    };
    responses: {
        /** @description The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing). */
        400: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example bad_request
                         * @enum {string}
                         */
                        code: "bad_request";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#bad-request
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description Although the HTTP standard specifies "unauthorized", semantically this response means "unauthenticated". That is, the client must authenticate itself to get the requested response. */
        401: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example unauthorized
                         * @enum {string}
                         */
                        code: "unauthorized";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#unauthorized
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description The client does not have access rights to the content; that is, it is unauthorized, so the server is refusing to give the requested resource. Unlike 401 Unauthorized, the client's identity is known to the server. */
        403: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example forbidden
                         * @enum {string}
                         */
                        code: "forbidden";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#forbidden
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description The server cannot find the requested resource. */
        404: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example not_found
                         * @enum {string}
                         */
                        code: "not_found";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#not-found
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description This response is sent when a request conflicts with the current state of the server. */
        409: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example conflict
                         * @enum {string}
                         */
                        code: "conflict";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#conflict
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description This response is sent when the requested content has been permanently deleted from server, with no forwarding address. */
        410: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example invite_expired
                         * @enum {string}
                         */
                        code: "invite_expired";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#invite-expired
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description The request was well-formed but was unable to be followed due to semantic errors. */
        422: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example unprocessable_entity
                         * @enum {string}
                         */
                        code: "unprocessable_entity";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#unprocessable-entity
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description The user has sent too many requests in a given amount of time ("rate limiting") */
        429: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example rate_limit_exceeded
                         * @enum {string}
                         */
                        code: "rate_limit_exceeded";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#rate-limit_exceeded
                         */
                        doc_url?: string;
                    };
                };
            };
        };
        /** @description The server has encountered a situation it does not know how to handle. */
        500: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": {
                    /** @example false */
                    success: boolean;
                    error: {
                        /**
                         * @description A short code indicating the error code returned.
                         * @example internal_server_error
                         * @enum {string}
                         */
                        code: "internal_server_error";
                        /**
                         * @description A human readable explanation of what went wrong.
                         * @example The requested resource was not found.
                         */
                        message: string;
                        /**
                         * @description A link to our documentation with more details about this error code
                         * @example https://docs.agentset.ai/api-reference/errors#internal-server_error
                         */
                        doc_url?: string;
                    };
                };
            };
        };
    };
    parameters: {
        /** @description The id of the namespace (prefixed with ns_) */
        NamespaceIdRef: string;
        /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
        TenantIdRef: string;
        /** @description The id of the job (prefixed with job_) */
        JobIdRef: string;
        /** @description The id of the document (prefixed with doc_) */
        DocumentIdRef: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    listNamespaces: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The retrieved namespaces */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["namespace"][];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    createNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    name: string;
                    slug: string;
                    /** @default {
                     *       "provider": "MANAGED_OPENAI",
                     *       "model": "text-embedding-3-large"
                     *     } */
                    embeddingConfig?: components["schemas"]["embedding-model-config"];
                    /** @default {
                     *       "provider": "MANAGED_PINECONE"
                     *     } */
                    vectorStoreConfig?: components["schemas"]["create-vector-store-config"];
                };
            };
        };
        responses: {
            /** @description The created namespace */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["namespace"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    getNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The retrieved namespace */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["namespace"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    deleteNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The deleted namespace */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["namespace"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    updateNamespace: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    name?: string;
                    slug?: string;
                };
            };
        };
        responses: {
            /** @description The updated namespace */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["namespace"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    listIngestJobs: {
        parameters: {
            query?: {
                statuses?: components["schemas"]["ingest-job-status"][];
                orderBy?: "createdAt";
                order?: "asc" | "desc";
                cursor?: components["schemas"]["pagination-cursor"];
                cursorDirection?: components["schemas"]["pagination-cursor-direction"];
                perPage?: number;
            };
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The retrieved ingest jobs */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["ingest-job"][];
                        pagination: {
                            nextCursor: string | null;
                            prevCursor: string | null;
                            hasMore: boolean;
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    createIngestJob: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The name of the ingest job. */
                    name?: string | null;
                    payload: components["schemas"]["ingest-job-payload"];
                    config?: components["schemas"]["ingest-job-config"];
                };
            };
        };
        responses: {
            /** @description The created ingest job */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["ingest-job"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    getIngestJobInfo: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
                /** @description The id of the job (prefixed with job_) */
                jobId: components["parameters"]["JobIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The retrieved ingest job */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["ingest-job"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    deleteIngestJob: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
                /** @description The id of the job (prefixed with job_) */
                jobId: components["parameters"]["JobIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The deleted ingest job */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["ingest-job"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    reIngestJob: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
                /** @description The id of the job (prefixed with job_) */
                jobId: components["parameters"]["JobIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The re-ingested job */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: {
                            /** @description The unique ID of the ingest job. */
                            id: string;
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    listDocuments: {
        parameters: {
            query?: {
                statuses?: components["schemas"]["document-status"][];
                orderBy?: "createdAt";
                order?: "asc" | "desc";
                ingestJobId?: string;
                cursor?: components["schemas"]["pagination-cursor"];
                cursorDirection?: components["schemas"]["pagination-cursor-direction"];
                perPage?: number;
            };
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The retrieved ingest jobs */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["document"][];
                        pagination: {
                            nextCursor: string | null;
                            prevCursor: string | null;
                            hasMore: boolean;
                        };
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    getDocument: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
                /** @description The id of the document (prefixed with doc_) */
                documentId: components["parameters"]["DocumentIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The retrieved ingest job */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["document"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    deleteDocument: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
                /** @description The id of the document (prefixed with doc_) */
                documentId: components["parameters"]["DocumentIdRef"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The deleted document */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["document"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    search: {
        parameters: {
            query?: never;
            header?: {
                /** @description Optional tenant id to use for the request. If not provided, the namespace will be used directly. Must be alphanumeric and up to 64 characters. */
                "x-tenant-id"?: components["parameters"]["TenantIdRef"];
            };
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    /** @description The query to search for. */
                    query: string;
                    /**
                     * @description The number of results to fetch from the vector store. Defaults to `10`.
                     * @default 10
                     */
                    topK?: number;
                    /**
                     * @description Whether to rerank the results. Defaults to `true`.
                     * @default true
                     */
                    rerank?: boolean;
                    /** @description The number of results to return after reranking. Defaults to `topK`. */
                    rerankLimit?: number;
                    /**
                     * @description The reranking model to use.
                     * @default cohere:rerank-v3.5
                     * @enum {string}
                     */
                    rerankModel?: "cohere:rerank-v3.5" | "cohere:rerank-english-v3.0" | "cohere:rerank-multilingual-v3.0" | "zeroentropy:zerank-1" | "zeroentropy:zerank-1-small";
                    /** @description A filter to apply to the results. */
                    filter?: {
                        [key: string]: unknown;
                    };
                    /** @description The minimum score to return. */
                    minScore?: number;
                    /**
                     * @description Whether to include relationships in the results. Defaults to `false`.
                     * @default false
                     */
                    includeRelationships?: boolean;
                    /**
                     * @description Whether to include metadata in the results. Defaults to `true`.
                     * @default true
                     */
                    includeMetadata?: boolean;
                    keywordFilter?: string;
                    /**
                     * @default semantic
                     * @enum {string}
                     */
                    mode?: "semantic" | "keyword";
                };
            };
        };
        responses: {
            /** @description The retrieved namespace */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: {
                            id: string;
                            score: number;
                            text?: string;
                            relationships?: {
                                [key: string]: unknown;
                            };
                            metadata?: {
                                file_directory: string;
                                filename: string;
                                filetype: string;
                                link_texts?: unknown[];
                                link_urls?: unknown[];
                                languages?: unknown[];
                                sequence_number?: number;
                            };
                        }[];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    createUpload: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["upload-file-schema"];
            };
        };
        responses: {
            /** @description Presigned URL generated successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["upload-result-schema"];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
    createBatchUpload: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the namespace (prefixed with ns_) */
                namespaceId: components["parameters"]["NamespaceIdRef"];
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": {
                    files: components["schemas"]["upload-file-schema"][];
                };
            };
        };
        responses: {
            /** @description Presigned URLs generated successfully */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": {
                        /** @constant */
                        success: true;
                        data: components["schemas"]["upload-result-schema"][];
                    };
                };
            };
            400: components["responses"]["400"];
            401: components["responses"]["401"];
            403: components["responses"]["403"];
            404: components["responses"]["404"];
            409: components["responses"]["409"];
            410: components["responses"]["410"];
            422: components["responses"]["422"];
            429: components["responses"]["429"];
            500: components["responses"]["500"];
        };
    };
}
